[{"title":"","date":"2017-04-02T00:46:45.596Z","path":"2017/04/02/Springboot学习分享文档（转载）/","text":"SpringBoot 学习分享文档（转载） SpringBoot简介 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。详情请参阅spirngboot官网：http://projects.spring.io/spring-boot/ SpringBoot特点 遵循“习惯优于配置”的原则，使用Spring Boot只需要很少的配置，大部分的时候我们直接使用默认的配置即可； 项目快速搭建，可以无需配置的自动整合第三方的框架； 可以完全不使用XML配置文件，只需要自动配置和Java Config； 内嵌Servlet容器，降低了对环境的要求，可以使用命令直接执行项目，应用可用jar包执行：java -jar； 提供了starter POM, 能够非常方便的进行包管理, 很大程度上减少了jar hell或者dependency hell； 运行中应用状态的监控； 与云计算的天然继承； SpringBoot优点 SpringBoot是伴随着Spring4.0诞生的，一经推出，引起了巨大的反向 从字面理解，Boot是引导的意思，因此SpringBoot帮助开发者快速搭建Spring框架； SpringBoot帮助开发者快速启动一个Web容器； SpringBoot继承了原有Spring框架的优秀基因； SpringBoot简化了使用Spring的过程； Spring Boot为我们带来了脚本语言开发的效率，但是Spring Boot并没有让我们意外的新技术，都是Java EE开发者常见的额技术。 SpringBoot解决的问题 Spring Boot使编码变简单 Spring Boot使配置变简单 Spring Boot使部署变简单 Spring Boot使监控变简单 SpringBoot的核心功能 （一）独立运行的Spring项目 Spring Boot可以以jar包的形式进行独立的运行，使用：java -jar xx.jar 就可以成功的运行项目，或者在应用项目的主程序中运行main函数即可；使得项目的部署，调试都变得简单。 （二）内嵌的Servlet容器 内嵌容器，使得我们可以执行运行项目的主程序main函数，使项目的快速运行； 主程序代码SpringbootDemoApplication.java import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class SpringbootDemoApplication { public static void main(String[] args) { SpringApplication.run(SpringbootDemoApplication.class, args); } } （三）提供starter简化Manen配置 Spring Boot提供了一系列的starter pom用来简化我们的Maven依赖,下边是创建一个简单web demo的依赖pom代码 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Spring Boot官网还提供了很多的starter pom，请参考： http://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/htmlsingle/#boot-documentation 或者访问https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters 通过粗略阅读，我们知道springboot几乎为市面上主流常见的框架接入做了starter pom整合，我们在使用的时候只要引入相关的starter，然后就可以直接使用（或者很少的配置）就可以使用该框架的功能为我们服务。 （四）自动配置SpringSpring Boot会根据我们项目中类路径的jar包/类，为jar包的类进行自动配置Bean，这样一来就大大的简化了我们的配置。当然，这只是Spring考虑到的大多数的使用场景，在一些特殊情况，我们还需要自定义自动配置； （五）无代码生成和XML配置Spring Boot神奇的地方不是借助于代码生成来实现的，而是通过条件注解的方式来实现的，这也是Spring 4.x的新特性。 Spring Boot的快速搭建案例 我们可以通过访问http://start.spring.io/来快速构建一个springboot应用，选好我们需要的模块后，回车或者点击Generate Project就会生成一个压缩包，把压缩包解压后导入我们的ide就可以运行一个demo项目。我们也可以通过idea的SPRING INITIALIZR来快速生成一个SpringBoot项目。 SpringBoot启动流程初探 阅读我们的demo代码，我们发现在main方法里我们执行了一串这样的代码SpringApplication.run(DemoApplication.class, args);查看run方法，发现这个run方法的方法说明为： /** * Static helper that can be used to run a {@link SpringApplication} from the * specified source using default settings. * @param source the source to load * @param args the application arguments (usually passed from a Java main method) * @return the running {@link ApplicationContext} */ public static ConfigurableApplicationContext run(Object source, String... args) { return run(new Object[] { source }, args); } 从这段说明和代码我们可以看到，该静态方法是用来启动我们的应用，特殊的配置使用默认设置，接收两个参数分别是我们的main方法所在的类，和main方法的方法参数，然后调用了当前类下的重载run方法。重载run方法如下： public static ConfigurableApplicationContext run(Object[] sources, String[] args) { return new SpringApplication(sources).run(args); } 从这段方法我们看到，该方法实例化了一个SpringApplication,c传入的参数依然为应用所在入口类，并且调用了SpringApplication下的run（String…args)方法。首先我们查看实例话的方法，也就是SpringApplication的构造函数： public SpringApplication(Object... sources) { initialize(sources); } 查看initialize方法： @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; }) private void initialize(Object[] sources) { if (sources != null &amp;&amp; sources.length &gt; 0) { this.sources.addAll(Arrays.asList(sources)); } this.webEnvironment = deduceWebEnvironment(); setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass(); } 从面的代码可以看到初始化过程做了以下几件事情this.webEnvironment = deduceWebEnvironment();这一个方法决定创建的是一个WEB应用还是一个SPRING的标准Standalone应用。进方法可以看到其是怎么判断的： private boolean deduceWebEnvironment() { for (String className : WEB_ENVIRONMENT_CLASSES) { if (!ClassUtils.isPresent(className, null)) { return false; } } return true; } 可以看到是根据org.springframework.util.ClassUtils的静态方法去判断classpath里面是否有WEB_ENVIRONMENT_CLASSES包含的类，如果有都包含则返回true则表示启动一个WEB应用，否则返回false启动一个标准Spring的应用。然后通过代码： private static final String[] WEB_ENVIRONMENT_CLASSES = { &quot;javax.servlet.Servlet&quot;, &quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot; }; 可以看到是否启动一个WEB应用就是取决于classpath下是否有javax.servlet.Servlet和org.springframework.web.context.ConfigurableWebApplicationContext。然后进入下一个阶段： setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); 这个方法是初始化classpath下的所有的可用的ApplicationContextInitializer setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); 这个方法是初使化classpath下的所有的可用的ApplicationListener。最后的执行deduceMainApplicationClass方法，找出main方法的全类名并返回其实例并设置到SpringApplication的this.mainApplicationClass完成初始化。 private Class&lt;?&gt; deduceMainApplicationClass() { try { StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) { if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) { return Class.forName(stackTraceElement.getClassName()); } } } catch (ClassNotFoundException ex) { // Swallow and continue } return null; } 然后调用SpringApplication实例的run方法来启动应用，代码如下： /** * Run the Spring application, creating and refreshing a new * {@link ApplicationContext}. * @param args the application arguments (usually passed from a Java main method) * @return a running {@link ApplicationContext} */ public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); } } 我们可以看到，这段代码作为整个应用启动的具体实现，还是比较复杂的，目前已知这里会加载SpringApplicationRunListener对整个容器的初始化过程进行监听： SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); 然后我们查看下面几行代码： ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); 首先是获取启动时传入参数args并初始化为ApplicationArguments对象SpringApplication.run(Application.class, args);取这里传入值。然后配置SpringBoot应用的环境： ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); 然后下面代码就是比较核心的： context = createApplicationContext(); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); 首先是createApplicationContext()方法： protected ConfigurableApplicationContext createApplicationContext() { Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) { try { contextClass = Class.forName(this.webEnvironment ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS); } catch (ClassNotFoundException ex) { throw new IllegalStateException( &quot;Unable create a default ApplicationContext, &quot; + &quot;please specify an ApplicationContextClass&quot;, ex); } } return (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass); } 可以看出根据这前初始化过程初始化的this.webEnvironment来决定初始化一个什么容器。如果classpath下是否有javax.servlet.Servlet和org.springframework.web.context.ConfigurableWebApplicationContext类，则使用DEFAULT_WEB_CONTEXT_CLASS初始化容器，如果不存在则用DEFAULT_CONTEXT_CLASS初始化容器。完成容器的创建工作。然后执行以下的几个步骤完成整个容器的创建与启动以及bean的注入功能。 prepareContext(context, environment, listeners, applicationArguments, printedBanner); 以下这一句代码是实现spring-boot-starter-*的自动化配置的关键。 refreshContext(context); afterRefresh(context, applicationArguments); 其中refreshContext会更新ApplicationContext基础组件，包括prepareBeanFactory工厂，postProcessBeanFactory工厂，监听器注册，消息流初始化等等操作。详情可以查看AbstractApplicationContext类下的refresh()方法。afterRefresh方法实质上使用的是callRunners(context, args);方法，代码如下： private void callRunners(ApplicationContext context, ApplicationArguments args) { List&lt;Object&gt; runners = new ArrayList&lt;Object&gt;(); runners.addAll(context.getBeansOfType(ApplicationRunner.class).values()); runners.addAll(context.getBeansOfType(CommandLineRunner.class).values()); AnnotationAwareOrderComparator.sort(runners); for (Object runner : new LinkedHashSet&lt;Object&gt;(runners)) { if (runner instanceof ApplicationRunner) { callRunner((ApplicationRunner) runner, args); } if (runner instanceof CommandLineRunner) { callRunner((CommandLineRunner) runner, args); } } } 可以看到，这里会把所有的bean放入一个List然后循环注册，其中值得注意的callRunner方法调用了ApplicationRunner接口的run方法，用以执行bean。 到现在为止，整个容器的启动流程基本完成，其中的各种Listener，创建Environment及Environment的初始化的内容都没有做过多深入的解析，有时间和有兴趣可以继续查看源代码 SpringBoot自动配置解析 我们先看@SpringBootApplication注解： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) 其中其中@Target，@Retention，@Documented，@Inherited这四个注解为元注解跳过。@ComponentScan这个是Spring很常用的注解，也跳过。我们先看@SpringBootConfiguration： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Configuration public @interface SpringBootConfiguration { } 这个注解里面的@Configuration标注当前类为：JavaConfig类 。然后我们来看@EnableAutoConfiguration注解 @SuppressWarnings(&quot;deprecation&quot;) @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(EnableAutoConfigurationImportSelector.class) 这个注解上@Import(EnableAutoConfigurationImportSelector.class)代表引入其它的Spring的JavaConfig接着进入EnableAutoConfigurationImportSelector.class我们发现该类继承了AutoConfigurationImportSelector，然后我们查看下下面的方法： @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } try { AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); configurations = sort(configurations, autoConfigurationMetadata); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return configurations.toArray(new String[configurations.size()]); } catch (IOException ex) { throw new IllegalStateException(ex); } } 进入：List configurations = getCandidateConfigurations(metadata,attributes); protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot; + &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations; } 在进入：List configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); 代码如下: public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) { String factoryClassName = factoryClass.getName(); try { Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); String factoryClassNames = properties.getProperty(factoryClassName); result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); } return result; } catch (IOException ex) { throw new IllegalArgumentException(&quot;Unable to load [&quot; + factoryClass.getName() + &quot;] factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex); } } 在上面的代码可以看到自动配置器会跟根据传入的factoryClass.getName()到spring.factories的文件中找到相应的key，从而加载里面的类，具体怎么加载的参考 SpringBoot启动流程初探中最后的refreshContext(context);实现。我们可以通过查看spring-boot-autoconfigure-1.5.2.RELEASE.jar下的META-INF里的spring.factories查看SpringBoot中支持的自动配置的类/第三方框架。这里以org.springframework.boot.autoconfigure.data.Redis.RedisAutoConfiguration为例查看代码如下： @Configuration @ConditionalOnClass({ JedisConnection.class, RedisOperations.class, Jedis.class }) @EnableConfigurationProperties(RedisProperties.class) public class RedisAutoConfiguration { @Configuration @ConditionalOnClass(GenericObjectPool.class) protected static class RedisConnectionConfiguration { @Bean @ConditionalOnMissingBean(RedisConnectionFactory.class) public JedisConnectionFactory redisConnectionFactory() throws UnknownHostException { return applyProperties(createJedisConnectionFactory()); } } @Configuration protected static class RedisConfiguration { @Bean @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) public RedisTemplate&lt;Object, Object&gt; redisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;Object, Object&gt;(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean(StringRedisTemplate.class) public StringRedisTemplate stringRedisTemplate( RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } } ｝ 把类简化一下基本上就可以看出这就是一个Spring的注解版的配置@ConditionalOnClass({ JedisConnection.class, RedisOperations.class, Jedis.class })这个注解的意思是：当存在JedisConnection.class, RedisOperations.class, Jedis.class三个类时才解析RedisAutoConfiguration配置类,否则不解析这一个配置类@ConditionalOnMissingBean(name = “redisTemplate”)这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行内部代码可以看出里面又定义了两个带@Configuration注解的配置类，这两个配置类会向SpringIOC容器注入可能3个bean：首先当类路径下存在(GenericObjectPool.class)时则注入JedisConnectionFactory 的实例如果Spring容器中不存在name = “redisTemplate”的实体，则创建RedisTemplate和StringRedisTemplate实例注入容器，这样在Spring的项目中，就可以用在任意的Spring管理的bean中注册用RedisTemplate和StringRedisTemplate的实例来对redis进入操作了。通过以上分析的过程我们可以发现只要一个基于SpringBoot项目的类路径下存在JedisConnection.class, RedisOperations.class, Jedis.class就可以触发自动化配置,意思说我们只要在maven的项目中依赖了spring-data-redis-1.7.2.RELEASE.jar和C:jedis-2.8.2.jar就可以触发自动配置,但这样不是每集成一个功能都要去分析里其自动化配置类，那就代不到开箱即用的效果了。所以Spring-boot为我提供了统一的starter可以直接配置好相关触发自动配置的所有的类的依赖集如redis的start如下： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 然后我们点击artifactId可以发现，spring-boot-starter-data-redis的源码中pom.xml文件中所有依赖: &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 因为maven依赖的传递性，我们只要依赖starter就可以看在类路径下配置好所有的触发自动配置的所有类，实现开箱即用的功能。通过这个对springboot自动配置原理的理解，我们甚至可以自己制作自己专有的starter也不是很困难的，只需要扩展一个spring.factories，然后在配置一个自己拥有的config类包含我们需要触发的规则就可以了。","tags":[]},{"title":"","date":"2017-04-02T00:46:45.594Z","path":"2017/04/02/SpringBatch 学习分享文档（转载）/","text":"SpringBatch 学习分享文档（转载） SpringBatch 简介 Spring Batch是一个轻量级的，完全面向Spring的批处理框架，可以应用于企业级大量的数据处理系统。Spring Batch以POJO和大家熟知的Spring框架为基础，使开发者更容易的访问和利用企业级服务。Spring Batch可以提供大量的，可重复的数据处理功能，包括日志记录/跟踪，事务管理，作业处理统计工作重新启动、跳过，和资源管理等重要功能。 SpringBatch技术概要： 利用Spring编程模型：使程序员专注于业务处理，让Spring框架管理流程。 明确分离批处理的执行环境和应用。 提供核心的，共通的接口。 提供开箱即用（out of the box）的简单的默认的核心执行接口。 提供Spring框架中配置、自定义、和扩展服务。 所有存在的核心服务可以很容的被替换和扩展，不影响基础层。 提供一个简单的部署模式，利用Maven构建独立的Jar文件。 SpringBatch主要组成 JobRepository : 用来注册Job的容器 JobLauncher : 用来启动Job的接口 Job : 实际执行的任务，包含一个或多个Step Step : Step 步骤，包含ItemReader、ItemProcessor、ItemWriter ItemReader : 用来读取数据的接口 ItemProcessor : 用来处理数据的接口 ItemWriter : 用来输出数据的接口 Spring Batch 的结构主要分为三层：应用层（Application），核心层（Batch Core）和基础架构层（Batch Infratrcture）。其中，应用层包含所有的批处理作业，通过Spring框架管理程序员自定义的代码。核心层包含了Batch启动和控制所需要的核心类，如：JobLauncher、Job和step等。应用层和核心层建立在基础构架层之上，基础构架层提供共通的读（ItemReader）、写（ItemWriter）、和服务（如ItemProcessor：数据处理接口。可以被应用层和核心层使用）。 SpringBatch初体验 经过官网文档的学习，我们已经能够通过springbatch进行一个简单的demo编写，demo代码地址：https://github.com/790712946/acer。查看demo，我们从job执行开始阅读，代码如下： @Autowired private JobLauncher jobLauncher; @Autowired private Job importUserJob; //每隔五秒执行一次 @Scheduled(fixedRate=5000) public void executeJob() throws JobParametersInvalidException, JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException { //以时间戳标识任务 JobParameters jobParameter=new JobParametersBuilder().addLong(&quot;time&quot;,System.currentTimeMillis()).toJobParameters(); JobExecution jobExecution=jobLauncher.run(importUserJob,jobParameter); } 其中@Scheduled为定时调度部分，不属于springbatch的内容，略过不提，我们可以发现springbatch里面的job都是通过JobLauncher的run方法来启动，查看run方法的实现，由于代码内容太长，我们分段进行阅读，首先 Assert.notNull(job, &quot;The Job must not be null.&quot;); Assert.notNull(jobParameters, &quot;The JobParameters must not be null.&quot;); 这里用断言对我们的两个参数进行了判断，不能为空，否则返回不能为空的异常信息。接着： final JobExecution jobExecution; JobExecution lastExecution = jobRepository.getLastJobExecution(job.getName(), jobParameters); if (lastExecution != null) { if (!job.isRestartable()) { throw new JobRestartException(&quot;JobInstance already exists and is not restartable&quot;); } 通过jobRepository.getLastJobExecution构建了一个job执行器，传入两个参数（任务名，任务参数），我们继续查看getLastJobExecution方法的类容： @Override public JobExecution getLastJobExecution(String jobName, JobParameters jobParameters) { JobInstance jobInstance = jobInstanceDao.getJobInstance(jobName, jobParameters); if (jobInstance == null) { return null; } JobExecution jobExecution = jobExecutionDao.getLastJobExecution(jobInstance); if (jobExecution != null) { jobExecution.setExecutionContext(ecDao.getExecutionContext(jobExecution)); stepExecutionDao.addStepExecutions(jobExecution); } return jobExecution; } 方法体内，首先通过jobInstanceDao.getJobInstance(jobName, jobParameters);构建了一个jobInstance，这里需要注意，jobInstanceDao有两种不同实现，一种是JdbcJobInstanceDao通过数据库查询实现，一种是MapJobInstanceDao通过内存缓存实现，接着对jobinstance进行了判断，如果为空就返回，否则继续执行，通过getLastJobExecution获取一个JobExecution，如果内存或者数据库中没有，则创建一个。接下来判断了一下任务是否允许重复执行job.isRestartable()，如果不允许则抛出一个异常（JobRestartException），接着判断了任务执行状态： for (StepExecution execution : lastExecution.getStepExecutions()) { if (execution.getStatus() == BatchStatus.UNKNOWN) { //throw throw new JobRestartException(&quot;Step [&quot; + execution.getStepName() + &quot;] is of status UNKNOWN&quot;); }//end if } 只要任务状态不为UNKNOWN则继续。紧接着对我们的jobParameters进行了验证： job.getJobParametersValidator().validate(jobParameters); 使用了默认的验证器，我们也可以自己扩展参数验证器。接下来： jobExecution = jobRepository.createJobExecution(job.getName(), jobParameters); 这里通过容器JobRepository创建了一个任务执行器。接下来，使用线程池TaskExecutor.execute执行我们的任务，主要关注 job.execute(jobExecution);方法，查看该方法， JobSynchronizationManager.register(execution); 向我们的序列化任务管理器注册了这个执行器。因为我们的任务是多线程执行的，所以这里面会序列话相关线程的信息。接着： jobParametersValidator.validate(execution.getJobParameters()); 验证参数有效性，通过if (execution.getStatus() != BatchStatus.STOPPING) 判断执行状态，如果任务没有停止则继续执行 execution.setStartTime(new Date()); updateStatus(execution, BatchStatus.STARTED); listener.beforeJob(execution); 这里设置了开始时间为当前时间，执行状态为开始了，然后执行了我们监听器中的beforeJob方法。接着执行doExecute方法，这里执行的就是我们的具体JOB了。这是个抽象接口，有三种不同的实现，分别是FlowJob，JsrFlowJob（JSR标准实现）,SimpleJob实现，这里我们只看下SimpleJob的实现，代码如下： protected void doExecute(JobExecution execution) throws JobInterruptedException, JobRestartException, StartLimitExceededException { StepExecution stepExecution = null; for (Step step : steps) { stepExecution = handleStep(step, execution); if (stepExecution.getStatus() != BatchStatus.COMPLETED) { // // Terminate the job if a step fails // break; } } 我们可以看到，这里是遍历了所有Step，然后通过handleStep来执行步骤，继续查看handleStep代码，核心逻辑为： step.execute(currentStepExecution); currentStepExecution.getExecutionContext().put(&quot;batch.executed&quot;, true); 可以看到，我们的步骤是通过step.execute（currentStepExecution）执行，查看执行代码，前面主要进行了一些开始时间，执行状态等设置和判断，我们只关注核心逻辑，代码如下： doExecutionRegistration(stepExecution); 注册执行器。 getCompositeListener().beforeStep(stepExecution); open(stepExecution.getExecutionContext()); 开启步骤监听器，执行beforeStep部分。 doExecute(stepExecution); 执行执行器，这是一个接口，有很多种实现，具体逻辑与Job执行器的执行方法类似，也是通过taskExecutor.execute进行多线程执行，最后调用Job的execute接口。接着会更新执行状态为COMPLETED。在finally里会对步骤执行器进行更新： exitStatus = exitStatus.and(stepExecution.getExitStatus()); stepExecution.setExitStatus(exitStatus); exitStatus = exitStatus.and(getCompositeListener().afterStep(stepExecution)); 注意，这里会执行我们监听器里的步骤执行完的事件，在Job里也是一样的，不做重复说明。 具体的业务逻辑和使用教程可以通过示例demo查看，这里不再说明。 总结 到这里，我们整个springbatch的执行流程都已经看完了，虽然各种状态流转没有怎么在文档里说明，但是基本都在我们的核心逻辑前后可以观察到，目前只是简单了解，接触时间不多，不够深入，但是我们已经可以在springbatch看见很多优秀的设计和使用方法，例如线程池的利用等。通过学习springbatch了解到了，批处理是一个非常复杂的流程，其中还有很多不是很明白的地方，喜欢在今后的时间里继续完善，了解。","tags":[]},{"title":"HEXO+Github,搭建属于自己的博客（转载）","date":"2016-12-17T13:45:12.000Z","path":"2016/12/17/HEXO-Github-搭建属于自己的博客（转载）/","text":"原文地址：http://www.jianshu.com/p/465830080ea9 经过各种找资料，踩过各种坑，终于使用 hexo 搭建个人博客初步完成了，域名目前用得时 github 的，我的 hexo 是 3.1.1 版本，hexo 不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。 本篇文章累计了大量评论，和我的一些解答，读者有什么问题可以先看看评论，或者搜下关键字，如果还是有问题可以给我在评论里给我留言，问题很着急的可以加我 ＱＱ：1499065178 ，或者给我发邮件：leopardpan@icloud.com ，都可以，如果你已经搭建完成了，可以看看我的另一篇博客HEXO进阶，有讲如何能百度搜索你的博客、多台电脑使用HEXO发布博客等。我现在的博客是使用 Jekyll 搭建的，如果你想使用我现在的模板请看Jekyll搭建个人博客 正文： 这边教程是针对与Mac的，参考链接，由于原文讲到的hexo是以前的老版本，所以现在的版本配置的时候会有些改动。 之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我，不是太喜欢，简书还算好点得。最近看到一些大神们的博客（在我的友情链接里有），貌似都是用hexo写得，我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。 配置环境安装Node（必须）作用：用来生成静态页面的到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git（必须）作用：把本地的hexo内容提交到github上去.安装Xcode就自带有Git，我就不多说了。 申请GitHub（必须）作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。 正式安装HEXO Node和Git都安装好后，可执行如下命令安装hexo： $ sudo npm install -g hexo 初始化创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令： hexo init 好啦，至此，全部安装工作已经完成！ 生成静态页面继续再Blog目录下执行如下命令，生成静态页面 hexo generate （hexo g 也可以） 本地启动启动本地服务，进行文章预览调试，命令： hexo server 浏览器输入http://localhost:4000我不知道你们能不能，反正我不能，因为我还有环境没配置好 常见的HEXO配置错误：12345ERROR Plugin load failed: hexo-server原因： Besides, utilities are separated into a standalone module. hexo.util is not reachable anymore.解决方法，执行命令：$ sudo npm install hexo-server 12345678910执行命令hexo server，提示：Usage: hexo&lt;Command&gt; ....原因：我认为是没有生成本地服务解决方法，执行命令：$ npm install hexo-server --save提示：hexo-server@0.1.2 node_modules/hexo-server.... 表示成功了[参考](https://hexo.io/zh-cn/docs/server.html) 这个时候再执行：$ hexo-server 得到: INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 这个时候再点击http://0.0.0.0:4000，正常情况下应该是最原始的画面，但是我看到的是：白板和Cannot GET / 几个字原因： 由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令： npm install hexo-renderer-ejs --save npm install hexo-renderer-stylus --save npm install hexo-renderer-marked --save 这个时候再重新生成静态文件，命令： hexo generate （或hexo g） 启动本地服务器： hexo server （或hexo s） 再点击网址http://0.0.0.0:4000 OK终于可以看到属于你自己的blog啦，?，虽然很简陋，但好歹有了一个属于自己的小窝了。参考链接，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。 配置Github建立Repository建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法然后建立关联，我的Blog在本地/Users/leopard/Blog，Blog是我之前建的东西也全在这里面，有： Blog ｜ ｜－－ _config.yml ｜－－ node_modules ｜－－ public ｜－－ source ｜－－ db.json ｜－－ package.json ｜－－ scaffolds ｜－－ themes 现在我们需要_config.yml文件，来建立关联，命令： vim _config.yml 翻到最下面，改成我这样子的，注意： : 后面要有空格 deploy: type: git repository: https://github.com/leopardpan/leopardpan.github.io.git branch: master 执行如下命令才能使用git部署 npm install hexo-deployer-git --save 网上会有很多说法，有的type是github, 还有repository 最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。然后，执行配置命令： hexo deploy 然后再浏览器中输入http://leopardpan.github.io/就行了，我的 github 的账户叫 leopardpan ,把这个改成你 github 的账户名就行了 部署步骤每次部署的步骤，可按以下三步来进行。 hexo clean hexo generate hexo deploy 一些常用命令： hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 这里有大量的主题列表使用方法里面都有详细的介绍，我就不多说了。我这里有几款个人认为不错的主题，免去你们，一个一个的选了，欢迎吐槽我的审美，? Cover - A chic theme with facebook-like cover photo Oishi - A white theme based on Landscape plus and Writing. Sidebar - Another theme based on Light with a simple sidebar TKL - A responsive design theme for Hexo. 一个设计优雅的响应式主题 Tinnypp - A clean, simple theme based on Tinny Writing - A small and simple hexo theme based on Light Yilia - Responsive and simple style 优雅简洁响应式主题，我用得就是这个。 Pacman voidy - A theme with dynamic tagcloud and dynamic snow 一些基本路径 文章在 source/_posts，编辑器可以用 Sublime，支持 markdown 语法。如果想修改头像可以直接在主题的 _config.yml 文件里面修改，友情链接，之类的都在这里，修改名字在 public/index.html 里修改，开始打理你的博客吧，有什么问题或者建议，都可以提出来，我会继续完善的。 Markdown语法参考链接: 作业部落 Q&amp;A 问：如何让文章想只显示一部分和一个 阅读全文 的按钮？答：在文章中加一个 &lt;!--more--&gt; ， &lt;!--more--&gt; 后面的内容就不会显示出来了。 问：本地部署成功了，也能预览效果，但使用 username.github.io 访问，出现 404 .答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了，你的 github 邮箱也要通过验证才行。","tags":[]},{"title":"Hello World","date":"2016-12-17T13:28:59.996Z","path":"2016/12/17/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]